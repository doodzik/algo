\documentclass{article}
\usepackage{listings}
\begin{document}

\chapter{Losungsbuch}

\section{Main}
In `main` werden die Daten initialisiet und das Programm immer wieder von vorne ausgefuhrt bis der Nutzer das programm schliesst.
Die eingabe der Befehle erfolgt hier, jedoch werden die Befehle in einer anderen Prozedur interpretiert und ausgefuhrt.
Das Ziel dahinter ist dass das Programm einfacher zu verstehen ist, da wir die Verantwortung teilen und hinter abstrakteren Prozeduren bundeln.

\section{CLI}
Die cli.c Prozeduren dienen als ein Adapter zwischen der eigentlichen Logik des Programms und der Ausenwelt.
Uber die funktion `cli_function` werden die Befehle des Nutzers Interpretiert und die jeweilige adapter Prozedur in cli.c aufgerufen.
Diese Funktionen gehen sicher dass die fur den gegebenen Befehls notwendigen Prozeduren ausgefuhrt werden.
Und das diese mit korreckten Daten verwendet werden.

\section{util}
In der util datei sind hilfreiche Prozeduren gespeichert die in keine der anderen Dateien platzfinden und auch keiner eigenen Datei bedurfen.
Wenn dies ein groseres Projekt ware hatte ich die Funktionen in eigene Dateien ausgelagernt.
Da sonst solch eine util Datei ein schwarzes Prozeduren-Loch fur Entwickler werden wurde.

\section{student}
In student.c sind alle Prozeduren implementiert die die Student Struktur betreffen.
Das interesannteste in der Datei ist wie ich das Subject Enum defeniere.
Ich brauche in meinem Code die Subjects einmal als Enum und als String.
Dafur benutzte ich den Preprozessor damit ich die Subjects nicht zweimal hinschreiben muss und damit sie in der gleichen Reihenfolge sind.

\section{cli_student}
In cli_student sind adapter Prozeduren fur student. siehe die Sektion CLI.

\section{student_list, doppelt und einfach}
Das Interface fur die Doppelt wie einfach Verkettete Liste ist bei mir die selbe, weswegen sie sich eine header Datei teilen.
Diese wird von den anderen Dateien included.
Damit wir angeben welche Listenform wir verwenden wollen mussen wir beim Kompilieren oder im Code `DOUBLE_LINKED_LIST` defenieren oder undefeniert lassen.
Daraufhin wird die die jeweilige Listenstruktur und implementation von student_list.h kompeliert.

\section{Makefile}
Das Makefile ist weitestgehend aus den Unterlagen ubernommen.
Ich habe dieses ledeglich fur meine Bedurfnisse erweitert.

Wichtig ist das sie mit `make` die einfache student_list kompilieren und mit `make double` die doppelte. 

\section{TODO}
Ich wurde das Pattern das ich in Main und CLI beschrieben habe strikter durchziehen.
Z.b. wurde ich in den Prozeduren von cli_student nicht direckt einen Studenten erzeugen sondern das die cli Funktionen machen lassen.
Zudem wurde ich die Liste als eine generische Implementieren wenn ich ich neu anfangen wurde.
Ausserdem wurde ich mehr mit Status Codes arbeiten. In der Cli habe ich versucht das zu implementieren. Dies ist jedoch in meinen Augen eher durftig umgesetzt worden.

\chapter{3}
   effizienter:
   (b) zum Hinzufügen eines Elements vor dem ersten Element.
   (a) Erstellen eines neuen Elements.
   (g) Löschen eines Elements.

   ineffizienter:
   (c) Hinzufügen eines Elements nach dem letzten Element.
    
\section{b}
Wir mussen keine verbindung zu vorherigen element setzten.
Dadurch spare ich 6 operationen.

\section{a}
Wir mussen keine verbindung zu vorherigen element setzten.
Dadurch spare ich 4 operationen.

\section{g}
Wir mussen keine verbindung zu vorherigen element setzten.
Dadurch spare ich 2 operationen.

\section{c}
Wir mussen die Liste einmal durchlaufen um ein element am ende hinzuzufugen O(n).
Bei einer Doppeltverketteten Liste ist es O(1), da wir uber den end Listenkopf direkt darauf zugreifen kann.

\chapter{5}

\section{ Meine Implementierung }

\begin{lstlisting}
void swapStudents(StudentList* prev, StudentList* next)
{
    Student* tmp = prev->student;  //2
    prev->student = next->student; //3
    next->student = tmp;           //2
}
// O(7)
\end{lstlisting}

\begin{lstlisting}
//selectionsort
void sortMatrikel(StudentList* sl)
{
    StudentList* j   = 0L;                                  //1
    StudentList* min = 0L;                                  //1
    StudentList* i   = sl;                                  //1
    while(i->next->next != 0L) {                            //3 ---------|
        i   =i->next;                                       //1          |
        min = i;                                            //1          |
        j   = i;                                            //1          |
        while (j->student != 0L){                           //2 ----|    | 
            if (j->student->id < min->student->id) min = j; //4/w/5 |    |
            j = j->next;                                    //2     |n   | n
        }                                                   //  ----|    |
        if(min != i) swapStudents(min, i);//13+n^2 | 9+n^2  //7          |
    }                                                       //  ---------|
}
/*
 1+1+1+n*(3+1+1+1+n*(2+5+2+7)) =>  n*n = O(n^2)
 1+1+1+n*(3+1+1+1+n*(2+4+2+7)) =>  n*n = Ω(n^2)
*/
\end{lstlisting}

\begin{lstlisting}
//bubblesort
void sortStudiengang(StudentList* sl)
{
    StudentList* i = sl;                                          //1
    int swaped = false;                                           //1
    do {                                                          /w/ ---------------|
        swaped = false;                                           //1                |
        while (i->next->next->student != 0L) {                    //4  ------|       |
            i=i->next;                                            //2        |       |
            if (i->student->subject > i->next->student->subject) {//6        |       |
                swapStudents(i, i->next);                         /w/8       | n     | n -> falls nicht sortiert
                swaped = true;                                    /w/9       |       |
            }                                                     //         |       |
        }                                                         //   ------|       |
        i = sl;                                                   //1                |
    } while (swaped);                                             // ----------------|
}
/*
1+1+n*(1+4+n*(2+6+8+9)+1 =>  n*n = O(n^2)
1+1+(1+4+n*(2+6)+1       =>  n   = Ω(n)
*/

\end{lstlisting}

\section{Allgemein}
Bubblesort ist aus "Algorithmen und Datenstrukturen" Auflage 5 von Thomas Ottmann und Peter Widmayer entnommen. 
Sellectionsort ist aus Donald Knuth's 'The Art of Computer Programming, Volume 3: Sorting and Searching'

\begin{lstlisting}
//Bubblesort
procedure bubblesort(var a: sequence);
  var i: integer;                                 //  1
  begin                                         
    repeat                                        /w/ -----------|
      for i:=1 to (N-1) do                        //    ---|     |
        if a[i].key > a[i+1].key                  //  6    | n   | n
          then {vertausche a[i] und a[i+1]}       /w/ 4 ---|     |
    until {keine Vertauschungen mehr auftreten}   // ------------|
  end
/*
1+n*(n*(6+4) =>  n*n = O(n^2)
1+n*(6)      =>  n   = Ω(n)
*/
\end{lstlisting}

\begin{lstlisting}
//Selectionsort
int i,j;                            //2
int iMin;                           //1 
for (j = 0; j < n-1; j++) {         //3 ---------|
    iMin = j;                       //1          |
    for ( i = j+1; i < n; i++) {    //3 -----|   |
        if (a[i] < a[iMin]) {       //1      |   |
            iMin = i;               /w/1     | n | n
        }                           //       |   |
    }                               //  -----|   |
    if(iMin != j) {                 //1          |
        swap(a[j], a[iMin]);        /w/3         | 
    }                               //           |
}                                   // ----------|
/*
2+1+3+n*(1+3+n*(1+1)+1+3) =>  n*n = O(n^2)
12+1+3+n*(1+3+n*(1)+1)    =>  n   = Ω(n)
*/

Die Komplexitat von meiner Implementierung unterscheided sich nicht von der Allgemeinen.

\end{lstlisting}

\section{Begrundung der Auswahl}
Die Algorithmen konnen genauso in einer einfach wie doppelt verketteten Liste implementiert ohne einen Komplexitats verlust zu erleiden. Im gegensatz zu Insertion sort zum Beispiel.
Zudem sind ist die Berechnung der Komplexitat auch einfacher und die Performance in dem Beispiel nicht wirklich relevant.

\end{document}
